零知识证明——面向非专业人员的简介

1)什么是零知识证明（ZK-Proofs），以及它的应用领域
零知识证明是一种方法，通过这种方法，可以说服另一个人在不显示事物本身的情况下了解某些事物。
更重要的是，之后那个人对该事物依然一无所知。
值得注意的一点是，零知识证明的本质就是在不揭晓我所知道或拥有的某样东西的前提下，
向别人证明我有很大几率（这点很重要，零知识证明说到底是一个概率上的证明）。

举个通俗易懂的例子，阿里巴巴知道打开藏着财宝的山洞的咒语。
强盗抓住他，让他说出咒语。
如果阿里巴巴说出咒语，就会因为没有利用价值而被杀死。
如果阿里巴巴坚持不说，强盗不会相信他真的掌握咒语，也会杀死他。
但阿里巴巴想了一个好办法，他对强盗说：“你们离我一箭之地，用弓箭指着我，你们举起右手我就念咒语打开石门，
举起左手我就念咒语关上石门，如果我做不到或逃跑，你们就用弓箭射死我。”

上述所举的例子是交互式零知识证明的例子，这在非交互式证明中情况会有所不同，证明可能会转移给验证者。
简单来说，非交互式零知识证明分为两个阶段：首先，用户使用模拟器(Simulator)运行协议，然后给出协议的副本，并说服其他人，证明是真实的。
因为是面向非专业人员的简介，详细的方法就不在这里展开。

实例

有几个用例，例如证明隐私密码，或证明拥有不想透露或给予任何人的秘密物品（例如秘密法律文件）。
在加密货币中，ZCash使用它们来证明 ZEC 的私人交易是否正确发生并且没有透露任何细节（包括其涉及的地址和数量）。

零知识证明的工作机制
用户在零知识系统中使用3个角色，分别是创建者(Creator)，证明者(Prover)和验证者(verifier)。 
某些类型的零知识证明系统不需要受信任的创建者，比如ZCash，接下来以使用零知识证明系统作为实例，来介绍与这些角色相关的重要安全注意事项。

创建者(Creator)
创建者是系统中的实体（它可以是单个人或其中的一组），首先决定系统设计中要证明的内容。
零知识系统中的单个实例仅提供此特定类型的证明。
例如，在ZCash中，这相当于定义了正确形成单个交易的标准。
即 ZCash Proofs仅证明交易是正确的。

这些系统的重要之处在于，在创建该系统时会产生随机性，这应该永远保密。
如果一个行为不端的人抓住这种随机性，他们就会伪造证明并破坏整个系统的有效性。
系统输出的结果是创建两个密钥：证明密钥和验证密钥，并根据角色分发给用户。

证明者(Creator)和验证者(Verifier)
日常运作中的两个主要角色是证明者和验证者。
证明器接收证明密钥，能够创建设置中所定义类型的特定证明。
验证者会收到验证密钥，可以验证某个证明是否正确。
当然，可以让一个用户同时成为证明者和验证者，前提是使用不同的密钥。
重要的一点是，证明者所知道的证明密钥是相同的，而所有验证者所知道的验证密钥也是相同的。
证明者证明其拥有一些秘密信息，通常每个证据都涉及公知的一些信息（即证明者和验证者都知晓的信息），这些信息不同于证据。
因此，单个证明包含此公共信息和仅由证明者（以及该证明者）知道的私人信息。

证明和验证
证明人使用证明密钥及其实例参数（公共和隐私输入）创建证明。 
这个过程是随机的：用相同的参数不断重复输入会产生不同的证明。
然后验证者获取此证明并通过添加公共输入的验证密钥,将所有内容提供给验证者算法(verifier algorithm)，以确定针对该输入的证明是否有效。
这个过程中不存在随机性：结果总是相同的（在加密证明中这是典型的做法，但它可以是随机的但是失败的概率可以忽略不计）

纵观零知识证明
这些系统是椭圆曲线对（Elliptic Curve Pairings）支持的加密结构，椭圆曲线配对也称双线性映射。 
椭圆曲线存在很多种，其中一些可以与其他一起配对使用，而有些不行，并且每种类型的曲线可以以不同的方式参数化，因此具有独特的名称。

下面介绍一些简明的非交互式知识证明(SNARKs)
PGHR13：最早并且最基本的 SNARK 之一，它引导了后续几种 SNARK 的变体

BCTV14a：PGHR13 的改进版本，优化效率，是最初在ZCash中实现的版本，去年6月 ZCash 又发现了漏洞。

Gro16：SNARK的另一种设计，不受PGHR13的启发。 实现更小的证明和更快的验证。

GM17：Gro16的演变

Sonic（参考了前面每一种 SNARK）：SNARK的一种新的不同方法，它避免了最近在BCTV14a中发现的漏洞。

Sonic（MBKM19）：最新的SNARK，不需要可靠的设置。

相关工具：

Libsnark：一个C ++库，它可以生成端到端的ZK 证明，从编写要证明的语句到生成密钥和证明。

Libff：一个C ++库，用于在大型代数组和字段中快速计算，以及特定种类的配对友好的椭圆曲线,由libsnark使用。

py_ecc：以太坊基金会的Python库，支持 SNN 的 BN128 和 BLS12-381 ，以及加密签名的 secp256k1。

Milagro：一个完整的加密库，涵盖多个平台，包括JavaScript，Go，Swift，C和Java,不专门用于SNARK。

DIZK：用于 SNARK 的Java库，是 libsnark 的镜像但只支持 Gro16。

ZoKrates：Rust / C ++工具，提供最佳的端到端体验来生成SNARK，因为它提供了一种简单的高级语言来指定要证明的语句,目前仅支持BCTV14a和GM17 Snarks。


