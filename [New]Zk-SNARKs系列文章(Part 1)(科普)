零知识证明，一系列概率协议中的一种，由Goldwasser,Micali和Rackoff 在1985年首次提出，
随着分布式账本技术(DLT)的兴起而大行其道。
本系列文章旨在介绍这项开创性工作背后的理论背景，并展示如何实现其复杂的组成“零件”，
最终实现端到端的零知识证明，遵循Pinocchio 协议并在 Python 中实现，
于此同时，还会介绍一些相关的应用程序。

那么，什么是 ZKP ,以及它能干什么呢？
简单来说，ZKP 允许证明人Alice向验证人Bob证明她知道某些信息而不透露其具体是什么。

举个例子，Alice想向Bob证明她知道一个非常大的非素数的因式分解而不揭露具体的因子或是数独谜题的解决方案而不透露具体步骤。

更一般的说，ZKP 可用作可验证计算的组成部分：一种将计算从相对较弱的客户端下载到计算能力更强的计算机的方法，
它使客户端能够以加密方式验证工作人员执行计算的正确性。

这是一个非常强大的范例，它在一定程度上影响了在线的隐私性，DLT和移动应用程序的可扩展性，以及云计算的安全性,等等....

ZKP 的另一个非常有前景的应用在于机器学习领域，它可用于证明拥有特定数据而无需完全公开，并使第三方能够确认在模型训练或预测过程中使用了特定数据。

值得一提的是，OpenMined是一个开创性的项目，正积极致力于多个加密原语，以创建一个隐私和安全机器学习的生态系统。

在计算机上，ZKP是由Alice精心设计的一系列数字，以及Bob可运行的一系列布尔检查，
以验证计算的正确性证明。因此，零知识协议是导出这些数字并定义验证检查的机制。

自Goldwasser，Micali和Rackoff在最初提出零知识证明以来，其领域的研究版本如雨后春笋般快速迭代更新，
这些协议之间的主要区别点之一是交互性。

在交互式零知识协议中，证明人和验证人彼此交换多个信息，直到验证人确信证明人知道某个秘密。

每次通信都可以看作是Bob提出的挑战,Alice 必须正确作答，
然后由Bob验证并且只有在通过协议指定的所有布尔检查后才接受。Bob 不知道秘密的概率随着轮数的不断迭代而不断降低，
知道Bob确信Alice的确知道这个秘密信息。

相反，在非交互式零知识协议中，证明人和验证人之间不存在重复通信，而是只有一轮，并且可以异步执行。
基于公开的数据，Alice生成证明并且Bob有权访问它。Bob可以在任意时间点验证证明。

值得注意的一点是，虽然Alice仅仅生成单个证明，而不是交互式证明中的生成多个证明，验证人Bob仍然可以确信Alice的确知道这个秘密信息。

非交互式证明的一个优点是它与证明人无关，并且证明人Alice所提出的证明是全局存在的，这意味着不仅仅是Bob,任何一个参与者都可以验证Alice的证明。

衡量零知识协议的另一个维度是简洁性，即处理Alice所生成证明的大小。简洁性在分布式账本的ZKP中扮演着重要的角色，它关乎着其存储空间和验证时间。

对于链上应用程序，生成的证明尽可能短并且与问题的规模无关以及恒定的验证时间是至关重要的。


读者可能会蹦出的一个问题是:是否存在交互式证明比非交互式的更适合的情况？
事实证明，非交互式有个比较大的缺陷是，它需要“可信设置”。简单来说，可信设置是Alice在计算证明时生成部分公共数据的过程。

我们会在稍后详细地讨论可信设置，但简单来说，可信设置依赖于在公共区域中发布一些数字的群体或某方。
任何有权访问随机源的人都可以生成假证明，这意味着这些方需要得到信任，但同时这也使得非交互式证明在实际操作过程中变得棘手。

然而，在很多情况下，非交互式或简洁性并没有想象中的那么好用。
非交互性仅仅在想要多个独立验证者验证给定数据而不必每个人单独查询证明人时才有用；
另外只有当存储介质非常昂贵或需要非常短的验证时间时，简洁性才会派上用场，但一般情况下，存储介质是非常便宜的。

这也意味着对于B2B程序，两个实体通过Http进行信道通信，可以使用交互式证明。
在用例中，两方公司可以充当Alice 和Bob,由验证者负责执行可信任设置，由于交互本质上是1对1 ，
因此验证者对伪造证明没有兴趣，没有必要将证明存储在链上，而Bob可以花更多的时间进行验证，因此这样的应用程序可以存在交互性设置。

那么，现在回到本系列文章的主题，零知识简洁的非交互式知识论，即 Zk-SNAKRs,它是最广泛使用的零知识协议，其中使用者包括匿名加密货币Zcash以及以太坊。





















