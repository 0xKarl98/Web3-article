以前面两篇短文为基础，将R1CS转换成QAP，需要将向量转换成多项式。
先定义多项式 $A_i(x),B_i(x),C_i(x)$,其中 i $\in$ [1,N], N表示的是约束向量中的元素数目，在本例中，N=4。
令 $A_i(n)=\vec a_{n,i}$,$B_i(n)=\vec b_{n,i}$,$C_i(n)=\vec c_{n,i}$,并基于这些点进行拉格朗日插值(Lagrange interpolation)

在本例中，$A_1(1)=0,A_1(2)=-4,A_2(1)=1,A_2(2)=0$
$B_i$和$C_i$同理可得
基于拉格朗日插值，可以得到下述多项式：
$A_1(x)=-4x+4$
$A_2(x)=-x+2$
$A_3(x)=x-1$
$A_4(x)=0$

$B_1(x)=x-1$
$B_2(x)=-x+2$
$B_3(x)=B_4(x)=0$

$C_1(x)=C_2(x)=0$
$C_3(x)=-x+2$
$C_4(x)=x-1$

基于此可将R1CS表达式用一个方程式表达出来：
$A(x)*B(x)-C(x)=H(x)*Z(x)$

其中 $\vec A(x)=(A_1(x) A_2(x) A_3(x) A_4(x))$
$\vec B(x)=(B_1(x) B_2(x) B_3(x) B_4(x))$
$\vec C(x)=(C_1(x) C_2(x) C_3(x) C_4(x))$
$A(x)=<\vec A,\vec s>$
$B(x)=<\vec B,\vec s>$
$C(x)=<\vec C,\vec s>$
$Z(x)=(x-1)(x-2)$

H(x)需要满足对于任意的x,等式$A(x)*B(x)-C(x)=H(x)*Z(x)$

在列出一堆不知所以的式子之后，读者会忍不住马上问：
1）这些式子究竟是用来干嘛的
2)什么是Z(x)
3)什么是H(x)

为了解答上面这三个问题，先来给出定义：
$\vec A(1)$ = $\vec a_1$
$\vec A(2)$ = $\vec a_2$
对$\vec B(x)$和$\vec C(x)$也给出类似的定义，再结合之前的A(x),B(x),C(x)，可以得出原始的 R1CS 系统相当于
A(x)*B(x)-C(x)=0 ,其中 x$\in${1,2}

而这也意味着多项式A(x)*B(x)-C(x)能够被(x-1)(x-2)整除，即：
$\exists H(x):A(x)*B(x)-C(x)=H(x)(x-1)(x-2)$

这解释了什么是H(x)和Z(x),但由谁计算并给出H(x)呢？

答案必须是证明人，因为基于计算过程(A(x)*B(x)-C(x))/Z(x),计算人可以知道 R1CS 下满足条件的解向量$\vec s$。

那么至此可以把 QAP 看成是由($\vec A(x),\vec B(x),\vec C(x),Z$)所构成的四元矢量组，并且QAP的解向量为$\vec s$

但是！我们需要这些来干嘛呢？

使用 Python 来构建程序会造成一些问题：
1）无法验证Alice运行了正确的程序
2）Bob如何在程序运行之后在不披露其它信息的请款小嘎得以窥见y值犹未可知。

基于将计算式转换成R1CS表达式，如果Bob看到有效的解向量$\vec s$,那么他就可以确定Alice所运行的程序是恰好对应的，而这已经解决了其中一个主要问题。

将R1CS转换成QAP，在数学层面上后者比前者推导多项式更富有成效，下一部分将会着眼于最近编写的问题来描述构建Zk-Snarks 的核心技术以揭示多项式的构建过程。









